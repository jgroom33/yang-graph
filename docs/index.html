<!DOCTYPE html>
<html>

<head>
  <title>YANG Graph Renderer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.30.1/cytoscape.min.js"></script>
  <!-- fcose dependencies -->
  <script src="https://unpkg.com/layout-base@2.0.0/layout-base.js"></script>
  <script src="https://unpkg.com/cose-base@2.0.0/cose-base.js"></script>
  <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.js"></script>
  <!-- cose-bilkent extension -->
  <script src="https://unpkg.com/cytoscape-cose-bilkent@4.1.0/cytoscape-cose-bilkent.js"></script>
  <style>
    #cy {
      width: 100%;
      height: 800px;
      border: 1px solid #ccc;
      position: relative;
      z-index: 1;
    }

    #node-info {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 300px;
      padding: 10px;
      border: 1px solid #ccc;
      background-color: #f9f9f9;
      z-index: 10;
    }

    #controls-container {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      z-index: 10;
      background-color: #fff;
    }

    #search-input {
      padding: 5px;
      width: 200px;
      margin-right: 5px;
    }

    #layout-select {
      padding: 5px;
      margin-top: 5px;
    }

    #simplify-button {
      padding: 5px;
      margin-top: 5px;
    }
  </style>
</head>

<body>
  <div id="controls-container">
    <div>
      <input type="text" id="search-input" placeholder="Search nodes by ID...">
      <button onclick="searchNodes()">Search</button>
    </div>
    <select id="layout-select">
      <option value="fcose">fcose (Force-Directed, Clustered)</option>
      <option value="cose-bilkent">cose-bilkent (Enhanced Force-Directed)</option>
      <option value="cose">cose (Force-Directed)</option>
      <option value="grid">Grid</option>
      <option value="circle">Circle</option>
      <option value="concentric">Concentric</option>
      <option value="breadthfirst">Breadth-First</option>
      <option value="random">Random</option>
    </select>
    <button id="refresh-button" onclick="relayout()">Relayout</button>
    <br/>
    <button id="simplify-button" onclick="toggleSimplify()">Simplify</button>
  </div>
  <div id="cy"></div>
  <div id="node-info">
    <h3>Node Information</h3>
    <p id="node-id">ID: N/A</p>
    <p id="node-module">Module: N/A</p>
    <p id="node-description">Description: N/A</p>
    <p id="node-key">Key: N/A</p>
    <p>Shift + Left-Click to prune a node</p> <!-- Instruction for user -->
  </div>
  <script>
    let cy;
    let simplifyMode = false;
    let prunedElements = [];

    // Register extensions
    if (typeof cytoscape !== 'undefined') {
      if (typeof cytoscapeFcose !== 'undefined') {
        cytoscape.use(cytoscapeFcose);
      } else {
        console.warn("fcose extension not loaded.");
      }
      if (typeof coseBilkent !== 'undefined') {
        cytoscape.use(coseBilkent);
      } else {
        console.warn("cose-bilkent extension not loaded.");
      }
    } else {
      console.error("Cytoscape core not loaded.");
      alert("Cytoscape failed to load; check console for details.");
    }

    // Layout configurations
    const layoutConfigs = {
      fcose: {
        name: "fcose",
        animate: true,
        quality: "default",
        randomize: true,
        nodeRepulsion: 8000,
        idealEdgeLength: 150,
        edgeElasticity: 0.45,
        nestingFactor: 0.1,
        gravity: 0.25,
        numIter: 2500,
        fit: true,
        padding: 50,
        nodeDimensionsIncludeLabels: true,
        packComponents: true,
      },
      "cose-bilkent": {
        name: "cose-bilkent",
        animate: true,
        nodeRepulsion: 6000,
        idealEdgeLength: 150,
        edgeElasticity: 0.45,
        nestingFactor: 0.1,
        gravity: 0.25,
        numIter: 2500,
        fit: true,
        padding: 50,
        randomize: true,
        nodeDimensionsIncludeLabels: true,
        packComponents: true,
      },
      cose: {
        name: "cose",
        animate: true,
        nodeRepulsion: 2000000,
        idealEdgeLength: 200,
        edgeElasticity: 0.3,
        gravity: 20,
        numIter: 2000,
        fit: true,
        padding: 60,
        nodeDimensionsIncludeLabels: true,
        randomize: true,
        componentSpacing: 100,
      },
      grid: {
        name: "grid",
        animate: true,
        fit: true,
        padding: 50,
        rows: undefined,
        columns: undefined,
      },
      circle: {
        name: "circle",
        animate: true,
        fit: true,
        padding: 50,
        radius: undefined,
        sort: (a, b) => a.data("id").localeCompare(b.data("id")),
      },
      concentric: {
        name: "concentric",
        animate: true,
        fit: true,
        padding: 50,
        levelWidth: () => 1,
        concentric: (node) => node.degree(),
      },
      breadthfirst: {
        name: "breadthfirst",
        animate: true,
        fit: true,
        padding: 50,
        directed: true,
        roots: undefined,
        maximal: false,
      },
      random: {
        name: "random",
        animate: true,
        fit: true,
        padding: 50,
      },
    };

    document.addEventListener("DOMContentLoaded", function () {
      fetch("graph.json")
        .then((response) => response.json())
        .then((data) => {
          const elements = data.graph || {
            nodes: data.nodes || [],
            edges: data.edges || [],
          };
          const nodes = (
            data.graph ? elements.filter((e) => e.data.id) : elements.nodes
          ).map((n) => n.data);
          const edges = (
            data.graph ? elements.filter((e) => !e.data.id) : elements.edges
          ).map((e) => e.data);

          const connectedNodeIds = new Set();
          edges.forEach((edge) => {
            connectedNodeIds.add(edge.source);
            connectedNodeIds.add(edge.target);
          });

          const filteredNodes = nodes.filter((node) => connectedNodeIds.has(node.id));
          const nodeIds = new Set(filteredNodes.map((n) => n.id));

          const placeholderNodes = [];
          edges.forEach((edge) => {
            if (!nodeIds.has(edge.target)) {
              placeholderNodes.push({
                id: edge.target,
                type: "unknown",
                module: edge.target.split(":")[0] || "unknown",
                description: "Referenced but not defined in processed YANG modules",
                key: null,
                isPlaceholder: true,
              });
              nodeIds.add(edge.target);
            }
          });

          const allNodes = filteredNodes.concat(placeholderNodes);
          const allElements = allNodes
            .map((n) => ({ data: n }))
            .concat(edges.map((e) => ({ data: e })));

          cy = cytoscape({
            container: document.getElementById("cy"),
            elements: allElements,
            style: [
              {
                selector: "node",
                style: {
                  shape: "roundrectangle",
                  label: function (ele) {
                    const id = ele.data("id");
                    return id.split(":").join("\n");
                  },
                  "background-color": "#0074D9",
                  color: "#fff",
                  "text-valign": "center",
                  "text-halign": "center",
                  width: function (ele) {
                    const id = ele.data("id");
                    const parts = id.split(":");
                    const longestPart = parts.reduce((a, b) => a.length > b.length ? a : b);
                    return Math.max(100, longestPart.length * 10) + "px";
                  },
                  height: "40px",
                  "font-size": "10px",
                  "font-weight": "bold",
                  "text-wrap": "wrap",
                  "text-max-width": function (ele) {
                    const id = ele.data("id");
                    const parts = id.split(":");
                    const longestPart = parts.reduce((a, b) => a.length > b.length ? a : b);
                    return (Math.max(90, longestPart.length * 10) - 10) + "px";
                  },
                  padding: "5px",
                },
              },
              {
                selector: "node[isPlaceholder]",
                style: {
                  "background-color": "#999999",
                  opacity: 0.6,
                  label: function (ele) {
                    const id = ele.data("id");
                    return id.split(":").join("\n") + "\n(missing)";
                  },
                  width: function (ele) {
                    const id = ele.data("id");
                    const parts = id.split(":");
                    const longestPart = parts.reduce((a, b) => a.length > b.length ? a : b);
                    return Math.max(100, longestPart.length * 10) + "px";
                  },
                  height: "100px",
                  "font-size": "10px",
                  "font-weight": "bold",
                  "text-wrap": "wrap",
                  "text-max-width": function (ele) {
                    const id = ele.data("id");
                    const parts = id.split(":");
                    const longestPart = parts.reduce((a, b) => a.length > b.length ? a : b);
                    return (Math.max(90, longestPart.length * 10) - 10) + "px";
                  },
                  padding: "5px",
                },
              },
              {
                selector: "node.second-line-larger",
                style: {
                  "font-size": function (ele) {
                    const id = ele.data("id");
                    const parts = id.split(":");
                    return parts.length > 1 ? "14px" : "10px";
                  },
                },
              },
              {
                selector: "node.highlighted",
                style: {
                  "background-color": "#FF4136",
                  "border-width": "2px",
                  "border-color": "#000",
                },
              },
              {
                selector: 'edge[relationship ^= "key"]',
                style: {
                  width: 2,
                  "line-color": "#2ECC40",
                  "target-arrow-color": "#2ECC40",
                  "target-arrow-shape": "triangle",
                  label: "data(relationship)",
                  "font-size": "10px",
                  "curve-style": "bezier",
                  "control-point-step-size": 50,
                },
              },
              {
                selector: 'edge[relationship = "references_type"]',
                style: {
                  width: 2,
                  "line-color": "#FF851B",
                  "target-arrow-color": "#FF851B",
                  "target-arrow-shape": "triangle",
                  label: "data(relationship)",
                  "font-size": "10px",
                  "curve-style": "bezier",
                  "control-point-step-size": 50,
                },
              },
              {
                selector: 'edge[relationship = "references_list"]',
                style: {
                  width: 2,
                  "line-color": "#7FDBFF",
                  "target-arrow-color": "#7FDBFF",
                  "target-arrow-shape": "triangle",
                  label: "data(relationship)",
                  "font-size": "10px",
                  "curve-style": "bezier",
                  "control-point-step-size": 50,
                },
              },
            ],
            layout: layoutConfigs["fcose"], // Default to fcose
          });

          cy.ready(function () {
            cy.nodes().forEach(function (node) {
              const id = node.data("id");
              if (id.split(":").length > 1) {
                node.addClass("second-line-larger");
              }
            });

            // Left-click handler: Show info or prune with Shift
            cy.on("tap", "node", function (evt) {
              const node = evt.target;
              const data = node.data();
              if (evt.originalEvent.shiftKey) { // Shift + Left-Click to prune
                console.log("Shift + Left-Click detected on node:", node.id());
                const connectedEdges = node.connectedEdges();
                const elementsToPrune = node.add(connectedEdges);
                prunedElements = prunedElements.concat(elementsToPrune);
                elementsToPrune.remove();
                const selectedLayout = document.getElementById("layout-select").value;
                // cy.layout(layoutConfigs[selectedLayout]).run();
              } else { // Plain Left-Click for info
                document.getElementById("node-id").textContent = `ID: ${data.id}`;
                document.getElementById("node-module").textContent = `Module: ${data.module}`;
                document.getElementById("node-description").textContent = `Description: ${data.description}`;
                document.getElementById("node-key").textContent = `Key: ${data.key || "N/A"}`;
              }
            });

            // Layout selection handler
            document.getElementById("layout-select").addEventListener("change", function (e) {
              const selectedLayout = e.target.value;
              const layout = cy.layout(layoutConfigs[selectedLayout]);
              layout.run();
            });
          });
        })
        .catch((error) => {
          console.error("Error loading or rendering graph:", error);
          alert("Failed to load graph.json. Check the console for details.");
        });
    });
    function relayout() {
      const selectedLayout = document.getElementById("layout-select").value;
      cy.layout(layoutConfigs[selectedLayout]).run();
    }

    function toggleSimplify() {
      simplifyMode = !simplifyMode;
      if (simplifyMode) {
        prunedElements = [];
        const targetNode = cy.getElementById('ciena-mef-fd:fd');
        if (targetNode.length > 0) {
          const connectedElements = cy.collection();
          const queue = [targetNode];

          while (queue.length > 0) {
            const node = queue.shift();
            if (!connectedElements.has(node)) {
              connectedElements.merge(node);
              const neighbors = node.closedNeighborhood();
              neighbors.forEach((neighbor) => {
                if (!connectedElements.has(neighbor)) {
                  queue.push(neighbor);
                }
              });
            }
          }

          cy.elements().not(connectedElements).forEach((ele) => {
            prunedElements.push(ele);
            ele.remove();
          });
        } else {
          alert('Node "ciena-mef-fd:fd" not found.');
        }
      } else {
        cy.add(prunedElements);
        prunedElements = [];
      }
      const selectedLayout = document.getElementById("layout-select").value;
      cy.layout(layoutConfigs[selectedLayout]).run();
    }

    function searchNodes() {
      const searchTerm = document.getElementById("search-input").value.trim().toLowerCase();
      if (!searchTerm) {
        cy.nodes().removeClass("highlighted");
        return;
      }

      cy.nodes().removeClass("highlighted");

      const matchedNodes = cy.nodes().filter((node) => {
        const nodeId = node.data("id").toLowerCase();
        return nodeId.includes(searchTerm);
      });

      if (matchedNodes.length > 0) {
        matchedNodes.addClass("highlighted");
        const firstMatch = matchedNodes[0];
        cy.animate({
          center: { eles: firstMatch },
          zoom: 1.5,
          duration: 500,
        });
      } else {
        alert("No nodes found matching: " + searchTerm);
      }
    }

    document.getElementById("search-input").addEventListener("keypress", function (e) {
      if (e.key === "Enter") {
        searchNodes();
      }
    });
  </script>
</body>

</html>